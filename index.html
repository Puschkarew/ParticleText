<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Sphere</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls h3 {
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group .value {
            font-size: 11px;
            color: #999;
            float: right;
        }
        
        #toggleControls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #toggleControls:hover {
            background: rgba(30, 30, 30, 0.95);
        }
        
        #controls.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Настройки объекта</h3>
        
        <div class="control-group">
            <label>
                Размер точек
                <span class="value" id="pointSizeValue">3</span>
            </label>
            <input type="range" id="pointSize" min="1" max="10" step="0.1" value="3">
        </div>
        
        <div class="control-group">
            <label>
                Количество точек
                <span class="value" id="particleCountValue">7500</span>
            </label>
            <input type="range" id="particleCount" min="3000" max="10000" step="500" value="7500">
        </div>
        
        <div class="control-group">
            <label>
                Сила воздействия
                <span class="value" id="forceStrengthValue">55</span>
            </label>
            <input type="range" id="forceStrength" min="5" max="100" step="5" value="55">
        </div>
        
        <div class="control-group">
            <label>
                Радиус воздействия
                <span class="value" id="interactionRadiusValue">4</span>
            </label>
            <input type="range" id="interactionRadius" min="0.5" max="5" step="0.1" value="4">
        </div>
        
        <div class="control-group">
            <label>
                Скорость возврата
                <span class="value" id="returnSpeedValue">0.030</span>
            </label>
            <input type="range" id="returnSpeed" min="0.01" max="0.2" step="0.01" value="0.030">
        </div>
        
        <div class="control-group">
            <label>
                Скорость пассивного движения
                <span class="value" id="autonomousMotionStrengthValue">0.005</span>
            </label>
            <input type="range" id="autonomousMotionStrength" min="0" max="0.05" step="0.002" value="0.005">
        </div>
        
    </div>
    
    <button id="toggleControls">Скрыть настройки</button>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        
        // Обработка ошибок загрузки
        window.addEventListener('error', (event) => {
            console.error('Глобальная ошибка:', event.error);
            const isModuleError = event.error && event.error.message && (
                event.error.message.includes('import') || 
                event.error.message.includes('CORS') || 
                event.error.message.includes('Failed to fetch') ||
                event.error.message.includes('module')
            );
            if (isModuleError) {
                const protocol = window.location.protocol;
                let errorMsg = 'Ошибка загрузки модулей. ';
                if (protocol === 'file:') {
                    errorMsg += 'Вы открыли файл через file:// протокол. ES модули не работают через file:// из-за CORS ограничений.<br><br>Используйте локальный сервер:<br>';
                    errorMsg += '• Python: <code>python -m http.server 8000</code><br>';
                    errorMsg += '• Node.js: <code>npx http-server</code><br>';
                    errorMsg += '• Затем откройте <code>http://localhost:8000</code>';
                } else {
                    errorMsg += 'Убедитесь, что ваш браузер поддерживает ES модули и import maps.';
                }
                errorMsg += '<br><br>Проверьте консоль браузера (F12) для деталей.';
                document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: monospace; background: #222; position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; z-index: 10000;">' + errorMsg + '</div>';
            }
        });
        
        // Также ловим unhandled promise rejections (могут быть при загрузке модулей)
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
        });

        // ========== ПАРАМЕТРЫ ==========
        let CONFIG = {
            particleCount: 7500,
            sphereRadius: 3.0, // Увеличиваем размер текста
            forceStrength: 55.0,
            interactionRadius: 4.0,
            returnSpeed: 0.030,
            pointSize: 3, // Размер точек
            autonomousMotionStrength: 0.005 // Сила автономного движения точек
        };

        // ========== НАСТРОЙКА SVG ==========
        // Путь к SVG файлу
        const SVG_PATH = 'Starting Point.svg';

        // ========== СОЗДАНИЕ КРУГЛОЙ ТЕКСТУРЫ ==========
        function createCircleTexture(size = 64) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const center = size / 2;
            
            // Простой белый круг без градиента
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath();
            ctx.arc(center, center, center, 0, Math.PI * 2);
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // ========== ИНИЦИАЛИЗАЦИЯ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Ортографическая камера для устранения перспективных искажений
        const viewSize = 20; // Размер видимой области
        const aspect = window.innerWidth / window.innerHeight;
        const left = -viewSize * aspect / 2;
        const right = viewSize * aspect / 2;
        const top = viewSize / 2;
        const bottom = -viewSize / 2;
        
        const camera = new THREE.OrthographicCamera(
            left,
            right,
            top,
            bottom,
            0.1,
            1000
        );
        camera.position.z = 12;
        camera.position.y = 0;
        camera.position.x = 0;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // ========== ЧАСТИЦЫ ==========
        let geometry = null;
        let positions = new Float32Array(CONFIG.particleCount * 3);
        let originalPositions = new Float32Array(CONFIG.particleCount * 3);
        let velocities = new Float32Array(CONFIG.particleCount * 3);
        let colors = new Float32Array(CONFIG.particleCount * 3); // Цвета для каждой точки (RGB)
        let points = null;
        let svgGeometry = null;
        
        const circleTexture = createCircleTexture(64);
        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: CONFIG.pointSize,
            transparent: true,
            opacity: 0.9,
            map: circleTexture,
            alphaTest: 0.1,
            sizeAttenuation: true,
            vertexColors: true // Включаем использование цветов вершин
        });
        
        console.log('Three.js загружен:', typeof THREE !== 'undefined');
        console.log('SVGLoader загружен:', typeof SVGLoader !== 'undefined');
        
        // Функция для проверки, находится ли точка внутри mesh (оптимизированная версия)
        // Использует меньше направлений для ускорения, но сохраняет точность
        function isPointInsideMesh(point, mesh, raycaster) {
            try {
                // #region agent log
                if (typeof window !== 'undefined' && !window._isPointInsideMeshCallCount) {
                    window._isPointInsideMeshCallCount = 0;
                }
                if (typeof window !== 'undefined') {
                    window._isPointInsideMeshCallCount++;
                    if (window._isPointInsideMeshCallCount % 100 === 0) {
                        fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:278',message:'isPointInsideMesh call count',data:{callCount:window._isPointInsideMeshCallCount},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                    }
                }
                // #endregion
                // Используем только 3 направления для ускорения (вместо 6)
                // Это достаточно для определения, находится ли точка внутри объёма
                const directions = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(0, 0, 1)
                ];
                
                let insideCount = 0;
                let totalChecks = 0;
                
                // Проверяем по каждому направлению
                for (const direction of directions) {
                    raycaster.set(point, direction);
                    const intersects = raycaster.intersectObject(mesh, false);
                    // Если нечётное число пересечений, точка внутри по этому направлению
                    const isInside = intersects.length % 2 === 1;
                    if (isInside) {
                        insideCount++;
                    }
                    totalChecks++;
                }
                
                // Точка считается внутри, если она внутри по большинству направлений (минимум 2 из 3)
                const threshold = Math.ceil(totalChecks * 0.6); // Минимум 2 из 3
                return insideCount >= threshold;
            } catch (error) {
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:310',message:'isPointInsideMesh error',data:{error:error.message},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                console.error('Ошибка в isPointInsideMesh:', error);
                return false;
            }
        }

        // Функция для получения точек для закрашивания SVG формы (2D плоскость)
        // Генерирует точки на поверхности SVG для их закрашивания
        function getShapeVolumePoints(shapeGeometry, count, raycaster) {
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:326',message:'getShapeVolumePoints entry',data:{count:count},timestamp:Date.now(),sessionId:'debug-session',runId:'hybrid-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            const points = [];
            const positions = shapeGeometry.attributes.position;
            const indices = shapeGeometry.index;
            
            // Получаем все вершины из геометрии текста
            const vertices = [];
            for (let i = 0; i < positions.count; i++) {
                const v = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                vertices.push(v);
            }
            
            // Вычисляем площади треугольников для равномерного распределения
            const triangles = [];
            let totalArea = 0;
            
            if (indices && indices.count > 0) {
                // Используем существующие индексы
                for (let i = 0; i < indices.count; i += 3) {
                    const i1 = indices.getX(i);
                    const i2 = indices.getX(i + 1);
                    const i3 = indices.getX(i + 2);
                    
                    const v1 = vertices[i1];
                    const v2 = vertices[i2];
                    const v3 = vertices[i3];
                    
                    // Вычисляем площадь треугольника
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const area = edge1.cross(edge2).length() * 0.5;
                    
                    // Игнорируем вырожденные треугольники (слишком маленькие)
                    if (area > 0.0001) {
                        triangles.push({ v1, v2, v3, area });
                        totalArea += area;
                    }
                }
            } else {
                // Если нет индексов, создаем треугольники из позиций напрямую
                for (let i = 0; i < vertices.length - 2; i += 3) {
                    const v1 = vertices[i];
                    const v2 = vertices[i + 1];
                    const v3 = vertices[i + 2];
                    
                    // Вычисляем площадь треугольника
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const area = edge1.cross(edge2).length() * 0.5;
                    
                    if (area > 0.0001) {
                        triangles.push({ v1, v2, v3, area });
                        totalArea += area;
                    }
                }
            }
            
            if (triangles.length === 0) {
                // Fallback: используем вершины
                if (vertices.length <= count) {
                    return vertices.map(v => v.clone());
                }
                const step = vertices.length / count;
                for (let i = 0; i < count; i++) {
                    const index = Math.floor(i * step);
                    points.push(vertices[index].clone());
                }
                return points;
            }
            
            // Вычисляем накопленные площади для взвешенного выбора треугольников
            const cumulativeAreas = [];
            let cumulativeSum = 0;
            for (const tri of triangles) {
                cumulativeSum += tri.area;
                cumulativeAreas.push(cumulativeSum);
            }
            
            // Фильтруем треугольники: используем только те, что обращены "вверх" (нормаль с положительным Z)
            // Это исключает внутренние грани отверстий
            const frontFacingTriangles = [];
            let frontFacingArea = 0;
            
            for (const tri of triangles) {
                // Вычисляем нормаль треугольника
                const edge1 = new THREE.Vector3().subVectors(tri.v2, tri.v1);
                const edge2 = new THREE.Vector3().subVectors(tri.v3, tri.v1);
                const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                
                // Используем только треугольники с нормалью, направленной вверх (Z > 0)
                // Это исключает внутренние грани отверстий
                if (normal.z > 0 && normal.length() > 0.0001) {
                    frontFacingTriangles.push({ ...tri, area: tri.area });
                    frontFacingArea += tri.area;
                }
            }
            
            // Если нет треугольников, обращённых вверх, используем все
            const trianglesToUse = frontFacingTriangles.length > 0 ? frontFacingTriangles : triangles;
            const areaToUse = frontFacingTriangles.length > 0 ? frontFacingArea : totalArea;
            
            // Вычисляем накопленные площади для выбранных треугольников
            const filteredCumulativeAreas = [];
            let filteredCumulativeSum = 0;
            for (const tri of trianglesToUse) {
                filteredCumulativeSum += tri.area;
                filteredCumulativeAreas.push(filteredCumulativeSum);
            }
            
            // Генерируем точки на поверхности букв (2D плоскость)
            const surfacePoints = [];
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:395',message:'generating 2D surface points',data:{triangleCount:triangles.length,frontFacingCount:trianglesToUse.length,needed:count},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // Генерируем точки на поверхности треугольников
            for (let i = 0; i < count; i++) {
                // Выбираем треугольник взвешенно по площади
                const randomArea = Math.random() * areaToUse;
                let triangleIndex = 0;
                for (let j = 0; j < filteredCumulativeAreas.length; j++) {
                    if (randomArea <= filteredCumulativeAreas[j]) {
                        triangleIndex = j;
                        break;
                    }
                }
                
                const triangle = trianglesToUse[triangleIndex];
                
                // Генерируем случайную точку на поверхности треугольника
                let u = Math.random();
                let v = Math.random();
                if (u + v > 1) {
                    u = 1 - u;
                    v = 1 - v;
                }
                const w = 1 - u - v;
                
                const surfacePoint = new THREE.Vector3();
                surfacePoint.addScaledVector(triangle.v1, u);
                surfacePoint.addScaledVector(triangle.v2, v);
                surfacePoint.addScaledVector(triangle.v3, w);
                
                // Устанавливаем Z в 0 для плоского текста (проецируем на плоскость Z=0)
                surfacePoint.z = 0;
                
                surfacePoints.push(surfacePoint);
            }
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:425',message:'point generation completed',data:{generated:surfacePoints.length,needed:count},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:420',message:'2D surface points generated',data:{generated:surfacePoints.length,needed:count,triangles:triangles.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // Если точек недостаточно, дублируем существующие
            if (surfacePoints.length === 0) {
                console.error('Не удалось сгенерировать точки! triangles:', triangles.length, 'vertices:', vertices.length);
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:450',message:'ERROR: no points generated',data:{triangles:triangles.length,vertices:vertices.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
                // #endregion
            } else if (surfacePoints.length < count) {
                // Если точек меньше нужного, дублируем существующие
                const needed = count - surfacePoints.length;
                for (let i = 0; i < needed; i++) {
                    const index = i % surfacePoints.length;
                    surfacePoints.push(surfacePoints[index].clone());
                }
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:455',message:'duplicated points to reach count',data:{original:surfacePoints.length-needed,duplicated:needed,final:surfacePoints.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
                // #endregion
            }
            
            // Возвращаем сгенерированные точки
            return surfacePoints.map(p => p.clone());
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:453',message:'getShapeVolumePoints exit',data:{returnedCount:points.length},timestamp:Date.now(),sessionId:'debug-session',runId:'hybrid-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            return points;
        }
        
        // Кэш для загруженного SVG
        let cachedSVGData = null;
        let svgLoadPromise = null;
        
        // Функция загрузки SVG (с кэшированием)
        function loadSVG() {
            // Если SVG уже загружен, возвращаем его сразу
            if (cachedSVGData) {
                return Promise.resolve(cachedSVGData);
            }
            
            // Если SVG уже загружается, возвращаем существующий промис
            if (svgLoadPromise) {
                return svgLoadPromise;
            }
            
            // Создаем новый промис для загрузки SVG
            svgLoadPromise = new Promise((resolve, reject) => {
                const loader = new SVGLoader();
                
                loader.load(
                    SVG_PATH,
                    (data) => {
                        cachedSVGData = data; // Кэшируем загруженный SVG
                        svgLoadPromise = null; // Сбрасываем промис после успешной загрузки
                        resolve(data);
                    },
                    undefined,
                    (error) => {
                        svgLoadPromise = null; // Сбрасываем промис при ошибке
                        reject(new Error(`Не удалось загрузить SVG: ${error}`));
                    }
                );
            });
            
            return svgLoadPromise;
        }
        
        // Функция создания геометрии из SVG
        async function createSVGGeometry(size = 2) {
            // Загружаем SVG (используем кэш, если он уже загружен)
            const svgData = await loadSVG();
            
            // Получаем paths из SVG
            if (!svgData.paths || svgData.paths.length === 0) {
                throw new Error('SVG не содержит path элементов');
            }
            
            // Собираем все shapes из всех paths
            const allShapes = [];
            
            for (const path of svgData.paths) {
                const shapesFromPath = SVGLoader.createShapes(path);
                allShapes.push(...shapesFromPath);
            }
            
            if (allShapes.length === 0) {
                throw new Error('Не удалось создать shapes из SVG paths');
            }
            
            // Создаем геометрию из всех shapes
            const geometries = [];
            
            for (const shape of allShapes) {
                const geometry = new THREE.ShapeGeometry(shape);
                geometries.push(geometry);
            }
            
            // Объединяем все геометрии в одну
            let mergedGeometry;
            if (geometries.length === 1) {
                mergedGeometry = geometries[0];
            } else {
                // Используем BufferGeometryUtils.mergeGeometries() вместо несуществующего метода merge()
                mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
            }
            
            // Вычисляем bounding box для масштабирования
            mergedGeometry.computeBoundingBox();
            const bbox = mergedGeometry.boundingBox;
            const svgWidth = bbox.max.x - bbox.min.x;
            const svgHeight = bbox.max.y - bbox.min.y;
            const svgMaxDimension = Math.max(svgWidth, svgHeight);
            
            // Масштабируем геометрию
            const scale = size / svgMaxDimension;
            mergedGeometry.scale(scale, -scale, 1); // Отрицательный Y для инверсии (SVG origin top-left, Three.js bottom-left)
            
            // Центрируем геометрию
            mergedGeometry.computeBoundingBox();
            mergedGeometry.center();
            mergedGeometry.computeBoundingBox();
            
            return mergedGeometry;
        }
        
        // Кэш для базового размера SVG (чтобы не вычислять каждый раз)
        let cachedSVGBaseSize = null;
        
        // Функция вычисления оптимального размера SVG
        async function calculateOptimalSVGSize(baseSize = 1.0) {
            if (cachedSVGBaseSize === null) {
                // Создаем временную геометрию для вычисления bounding box
                const tempGeometry = await createSVGGeometry(baseSize);
                tempGeometry.computeBoundingBox();
                
                // Вычисляем размер SVG
                const bbox = tempGeometry.boundingBox;
                const svgWidth = bbox.max.x - bbox.min.x;
                const svgHeight = bbox.max.y - bbox.min.y;
                cachedSVGBaseSize = Math.max(svgWidth, svgHeight);
                
                // Освобождаем память
                tempGeometry.dispose();
            }
            
            // Для ортографической камеры видимая ширина не зависит от расстояния
            // Вычисляем видимую ширину из параметров камеры
            const visibleWidth = camera.right - camera.left;
            
            // Масштабируем SVG так, чтобы он занимал максимум 80% видимой ширины
            // Возвращаем базовый scaleFactor (для sphereRadius=1.0)
            const targetWidth = visibleWidth * 0.8;
            const baseScaleFactor = targetWidth / cachedSVGBaseSize;
            
            return baseScaleFactor;
        }
        
        // Функция генерации частиц на основе SVG
        async function generateParticlesFromSVG() {
            // Всегда пересоздаем геометрию, если она не существует
            // Вычисляем базовый масштаб для SVG (для sphereRadius=1.0, SVG занимает 80% ширины)
            const baseScaleFactor = await calculateOptimalSVGSize();
            
                // Применяем CONFIG.sphereRadius как множитель, но ограничиваем максимальный размер
                // чтобы SVG всегда помещался во вьюпорт (максимум 95% видимой ширины)
                // Для ортографической камеры видимая ширина не зависит от расстояния
                const visibleWidth = camera.right - camera.left;
                const maxSVGWidth = visibleWidth * 0.95; // Максимум 95% ширины
            
            // Вычисляем максимально допустимый scaleFactor
            const maxScaleFactor = maxSVGWidth / cachedSVGBaseSize;
            
            // Применяем sphereRadius, но ограничиваем максимальным размером
            const scaleFactor = Math.min(baseScaleFactor * CONFIG.sphereRadius, maxScaleFactor);
            const finalSize = scaleFactor;
            
            // Создаем финальную геометрию с правильным размером
            svgGeometry = await createSVGGeometry(finalSize);
            svgGeometry.computeBoundingBox();
            
            // Используем raycaster для проверки точек внутри объёма
            const tempRaycaster = new THREE.Raycaster();
            const volumePoints = getShapeVolumePoints(svgGeometry, CONFIG.particleCount, tempRaycaster);
            
            positions = new Float32Array(CONFIG.particleCount * 3);
            originalPositions = new Float32Array(CONFIG.particleCount * 3);
            velocities = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);
            
            let particlesCreated = 0;
            let posMinX=Infinity,posMaxX=-Infinity,posMinY=Infinity,posMaxY=-Infinity,posMinZ=Infinity,posMaxZ=-Infinity;
            for (let i = 0; i < CONFIG.particleCount && i < volumePoints.length; i++) {
                const i3 = i * 3;
                const point = volumePoints[i];
                
                positions[i3] = point.x;
                positions[i3 + 1] = point.y;
                positions[i3 + 2] = point.z;
                
                posMinX=Math.min(posMinX,point.x);posMaxX=Math.max(posMaxX,point.x);
                posMinY=Math.min(posMinY,point.y);posMaxY=Math.max(posMaxY,point.y);
                posMinZ=Math.min(posMinZ,point.z);posMaxZ=Math.max(posMaxZ,point.z);
                
                originalPositions[i3] = point.x;
                originalPositions[i3 + 1] = point.y;
                originalPositions[i3 + 2] = point.z;
                
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                
                // Инициализируем цвета как белые (1, 1, 1)
                colors[i3] = 1.0;
                colors[i3 + 1] = 1.0;
                colors[i3 + 2] = 1.0;
                particlesCreated++;
            }
        }
        
        // Функция пересоздания системы точек
        async function recreateParticles() {
            await generateParticlesFromSVG();
            
            if (points) {
                scene.remove(points);
                geometry.dispose();
            }
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            points = new THREE.Points(geometry, material);
            scene.add(points);
        }
        
        // Функция масштабирования SVG объекта
        async function scaleSVGObject(newSize) {
            CONFIG.sphereRadius = newSize;
            
            // Пересоздаем SVG геометрию с новым размером
            svgGeometry = null;
            cachedSVGBaseSize = null; // Сбрасываем кэш размера
            await generateParticlesFromSVG();
            
            // Обновляем геометрию точек
            if (points) {
                scene.remove(points);
                if (geometry) {
                    geometry.dispose();
                }
            }
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            points = new THREE.Points(geometry, material);
            scene.add(points);
        }
        
        // Флаг готовности
        let isInitialized = false;
        
        // Инициализация
        (async () => {
            try {
                await generateParticlesFromSVG();
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                points = new THREE.Points(geometry, material);
                scene.add(points);
                isInitialized = true;
                console.log('Инициализация завершена успешно');
            } catch (error) {
                console.error('Ошибка при инициализации SVG:', error);
                document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: monospace; background: #222; position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; z-index: 10000; flex-direction: column; text-align: center;"><h2>Ошибка загрузки SVG</h2><p>Не удалось загрузить SVG файл "Starting Point.svg".</p><p style="color: #999; font-size: 12px; margin-top: 20px;">Проверьте консоль браузера (F12) для деталей.</p></div>';
            }
        })();
        
        // ========== ВЗАИМОДЕЙСТВИЕ ==========
        const mouse = new THREE.Vector2();
        const mouse3D = new THREE.Vector3();
        const previousMouse = new THREE.Vector2();
        const mouseVelocity = new THREE.Vector2();
        
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        
        function updateMousePosition(event) {
            previousMouse.copy(mouse);
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            mouseVelocity.x = mouse.x - previousMouse.x;
            mouseVelocity.y = mouse.y - previousMouse.y;
            
            raycaster.setFromCamera(mouse, camera);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectionPoint);
            mouse3D.copy(intersectionPoint);
        }
        
        let isPointerDown = false;
        
        function onPointerMove(event) {
            updateMousePosition(event);
        }
        
        function onPointerDown(event) {
            isPointerDown = true;
            updateMousePosition(event);
        }
        
        function onPointerUp(event) {
            isPointerDown = false;
        }
        
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        
        // ========== ФИЗИКА ==========
        const tempVector = new THREE.Vector3();
        const tempVector2 = new THREE.Vector3();
        const tempVector3 = new THREE.Vector3();
        
        function updatePhysics() {
            // Проверяем, что геометрия инициализирована
            if (!isInitialized || !geometry || !geometry.attributes.position) {
                return;
            }
            
            const positionsArray = geometry.attributes.position.array;
            const colorsArray = geometry.attributes.color ? geometry.attributes.color.array : null;
            
            // Проверяем, что массив имеет правильный размер
            const actualParticleCount = Math.min(CONFIG.particleCount, positionsArray.length / 3);
            
            // Определяем диапазон расстояний для нормализации
            let minDistance = Infinity;
            let maxDistance = -Infinity;
            const distances = [];
            
            // Сначала вычисляем все расстояния
            for (let i = 0; i < actualParticleCount; i++) {
                const i3 = i * 3;
                if (i3 + 2 >= positionsArray.length) break;
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                const distance = tempVector.distanceTo(camera.position);
                distances.push(distance);
                minDistance = Math.min(minDistance, distance);
                maxDistance = Math.max(maxDistance, distance);
            }
            
            // Нормализуем диапазон, чтобы избежать слишком резких переходов
            const distanceRange = Math.max(maxDistance - minDistance, 0.1);
            
            const speed = Math.sqrt(mouseVelocity.x * mouseVelocity.x + mouseVelocity.y * mouseVelocity.y);
            const forceMultiplier = Math.min(speed * CONFIG.forceStrength, CONFIG.forceStrength * 2);
            
            for (let i = 0; i < actualParticleCount; i++) {
                const i3 = i * 3;
                if (i3 + 2 >= positionsArray.length) break;
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                
                const distance = tempVector.distanceTo(mouse3D);
                
                if (distance < CONFIG.interactionRadius && (isPointerDown || speed > 0.001)) {
                    const direction = tempVector2.subVectors(tempVector, mouse3D).normalize();
                    const force = (1 - distance / CONFIG.interactionRadius) * forceMultiplier;
                    
                    velocities[i3] += direction.x * force * 0.2;
                    velocities[i3 + 1] += direction.y * force * 0.2;
                    velocities[i3 + 2] += direction.z * force * 0.2;
                }
                
                // Автономное движение - плавные случайные силы (применяются не каждый кадр для плавности)
                if (CONFIG.autonomousMotionStrength > 0 && Math.random() < 0.3) {
                    velocities[i3] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3;
                    velocities[i3 + 1] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3;
                    velocities[i3 + 2] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3;
                }
                
                positionsArray[i3] += velocities[i3];
                positionsArray[i3 + 1] += velocities[i3 + 1];
                positionsArray[i3 + 2] += velocities[i3 + 2];
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                
                velocities[i3] *= 0.92;
                velocities[i3 + 1] *= 0.92;
                velocities[i3 + 2] *= 0.92;
                
                tempVector3.set(
                    originalPositions[i3],
                    originalPositions[i3 + 1],
                    originalPositions[i3 + 2]
                );
                
                const returnForce = tempVector2.subVectors(tempVector3, tempVector);
                positionsArray[i3] += returnForce.x * CONFIG.returnSpeed;
                positionsArray[i3 + 1] += returnForce.y * CONFIG.returnSpeed;
                positionsArray[i3 + 2] += returnForce.z * CONFIG.returnSpeed;
                
                // Обновляем цвет на основе расстояния от камеры
                if (colorsArray && i < distances.length && i3 + 2 < colorsArray.length) {
                    const distance = distances[i];
                    // Нормализуем расстояние от 0 до 1
                    const normalizedDistance = distanceRange > 0 ? (distance - minDistance) / distanceRange : 0;
                    // Инвертируем: ближние точки ярче (1.0), дальние бледнее (0.3)
                    const brightness = 1.0 - normalizedDistance * 0.7; // От 1.0 до 0.3
                    const clampedBrightness = Math.max(0.3, Math.min(1.0, brightness));
                    
                    colorsArray[i3] = clampedBrightness;
                    colorsArray[i3 + 1] = clampedBrightness;
                    colorsArray[i3 + 2] = clampedBrightness;
                }
            }
            
            geometry.attributes.position.needsUpdate = true;
            if (geometry.attributes.color) {
                geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // ========== ПАНЕЛЬ НАСТРОЕК ==========
        const controls = document.getElementById('controls');
        const toggleBtn = document.getElementById('toggleControls');
        
        toggleBtn.addEventListener('click', () => {
            controls.classList.toggle('hidden');
            toggleBtn.textContent = controls.classList.contains('hidden') ? 'Показать настройки' : 'Скрыть настройки';
        });
        
        // Привязка слайдеров к значениям
        function setupControl(id, configKey, valueId) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                CONFIG[configKey] = value;
                
                // Форматирование значения в зависимости от параметра
                if (id === 'autonomousMotionStrength' || id === 'returnSpeed') {
                    valueDisplay.textContent = value.toFixed(3);
                } else if (value < 1) {
                    valueDisplay.textContent = value.toFixed(2);
                } else {
                    valueDisplay.textContent = value.toFixed(0);
                }
                
                if (id === 'pointSize') {
                    material.size = value;
                }
            });
        }
        
        setupControl('pointSize', 'pointSize', 'pointSizeValue');
        setupControl('forceStrength', 'forceStrength', 'forceStrengthValue');
        setupControl('interactionRadius', 'interactionRadius', 'interactionRadiusValue');
        setupControl('returnSpeed', 'returnSpeed', 'returnSpeedValue');
        setupControl('autonomousMotionStrength', 'autonomousMotionStrength', 'autonomousMotionStrengthValue');
        
        // Обработчик для количества точек с debounce для оптимизации
        const particleCountSlider = document.getElementById('particleCount');
        const particleCountValue = document.getElementById('particleCountValue');
        let particleCountTimeout = null;
        particleCountSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            CONFIG.particleCount = value;
            particleCountValue.textContent = value;
            
            // Debounce: пересоздаём частицы только после остановки изменения слайдера
            clearTimeout(particleCountTimeout);
            particleCountTimeout = setTimeout(async () => {
                await recreateParticles();
            }, 300); // Ждём 300ms после последнего изменения
        });
        
        
        // ========== АНИМАЦИЯ ==========
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            // Обновляем параметры ортографической камеры при изменении размера окна
            const viewSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
