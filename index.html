<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Sphere</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 400vh;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }
        
        #controls h3 {
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group .value {
            font-size: 11px;
            color: #999;
            float: right;
        }
        
        #toggleControls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        #toggleControls:hover {
            background: rgba(30, 30, 30, 0.95);
        }
        
        #controls.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Настройки объекта</h3>
        
        <div class="control-group">
            <label>
                Размер точек
                <span class="value" id="pointSizeValue">6</span>
            </label>
            <input type="range" id="pointSize" min="1" max="10" step="0.1" value="6">
        </div>
        
        <div class="control-group">
            <label>
                Количество точек
                <span class="value" id="particleCountValue">3000</span>
            </label>
            <input type="range" id="particleCount" min="3000" max="10000" step="500" value="3000">
        </div>
        
        <div class="control-group">
            <label>
                Сила воздействия
                <span class="value" id="forceStrengthValue">100</span>
            </label>
            <input type="range" id="forceStrength" min="5" max="100" step="5" value="100">
        </div>
        
        <div class="control-group">
            <label>
                Радиус воздействия
                <span class="value" id="interactionRadiusValue">4</span>
            </label>
            <input type="range" id="interactionRadius" min="0.5" max="5" step="0.1" value="4">
        </div>
        
        <div class="control-group">
            <label>
                Жёсткость пружины
                <span class="value" id="springConstantValue">0.15</span>
            </label>
            <input type="range" id="springConstant" min="0.1" max="1.0" step="0.05" value="0.15">
        </div>
        
        <div class="control-group">
            <label>
                Демпфирование
                <span class="value" id="dampingValue">0.93</span>
            </label>
            <input type="range" id="damping" min="0.85" max="0.99" step="0.01" value="0.93">
        </div>
        
        <div class="control-group">
            <label>
                Скорость анимации
                <span class="value" id="timeScaleValue">0.80</span>
            </label>
            <input type="range" id="timeScale" min="0.1" max="1.0" step="0.05" value="0.80">
        </div>
        
        <div class="control-group">
            <label>
                Скорость пассивного движения
                <span class="value" id="autonomousMotionStrengthValue">0.005</span>
            </label>
            <input type="range" id="autonomousMotionStrength" min="0" max="0.05" step="0.002" value="0.005">
        </div>
        
        <div class="control-group">
            <label>
                Сила разлёта при скролле
                <span class="value" id="scrollSpreadForceValue">50</span>
            </label>
            <input type="range" id="scrollSpreadForce" min="0" max="100" step="5" value="50">
        </div>
        
        <div class="control-group" style="display: none;">
            <label>
                Глубина скролла (vh)
                <span class="value" id="scrollDepthValue">300</span>
            </label>
            <input type="range" id="scrollDepth" min="0" max="500" step="10" value="300">
        </div>
        
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 10px; color: #666;">
            Версия: scroll-spread-v3-20250116
        </div>
        
    </div>
    
    <button id="toggleControls">Скрыть настройки</button>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        
        // Обработка ошибок загрузки
        window.addEventListener('error', (event) => {
            console.error('Глобальная ошибка:', event.error);
            const isModuleError = event.error && event.error.message && (
                event.error.message.includes('import') || 
                event.error.message.includes('CORS') || 
                event.error.message.includes('Failed to fetch') ||
                event.error.message.includes('module')
            );
            if (isModuleError) {
                const protocol = window.location.protocol;
                let errorMsg = 'Ошибка загрузки модулей. ';
                if (protocol === 'file:') {
                    errorMsg += 'Вы открыли файл через file:// протокол. ES модули не работают через file:// из-за CORS ограничений.<br><br>Используйте локальный сервер:<br>';
                    errorMsg += '• Python: <code>python -m http.server 8000</code><br>';
                    errorMsg += '• Node.js: <code>npx http-server</code><br>';
                    errorMsg += '• Затем откройте <code>http://localhost:8000</code>';
                } else {
                    errorMsg += 'Убедитесь, что ваш браузер поддерживает ES модули и import maps.';
                }
                errorMsg += '<br><br>Проверьте консоль браузера (F12) для деталей.';
                document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: monospace; background: #222; position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; z-index: 10000;">' + errorMsg + '</div>';
            }
        });
        
        // Также ловим unhandled promise rejections (могут быть при загрузке модулей)
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
        });

        // ========== ПАРАМЕТРЫ ==========
        let CONFIG = {
            particleCount: 3000,
            sphereRadius: 3.0, // Увеличиваем размер текста
            forceStrength: 100.0,
            interactionRadius: 4.0,
            returnSpeed: 0.030, // Оставляем для обратной совместимости, но используем springConstant
            springConstant: 0.15, // Жёсткость пружины (сила возврата)
            damping: 0.93, // Коэффициент демпфирования (затухание колебаний, чем ближе к 1, тем сильнее затухание)
            timeScale: 0.80, // Глобальный множитель скорости анимации (0.5 = в 2 раза медленнее)
            pointSize: 6, // Размер точек
            autonomousMotionStrength: 0.005, // Сила автономного движения точек
            chaosAngle: 45, // Максимальный угол отклонения направления (градусы)
            chaosStrength: 0.8, // Сила хаотичности (0-1)
            tangentialForceRatio: 0.4, // Соотношение тангенциальной силы
            zAxisStrength: 0.6, // Сила Z-компоненты (глубина)
            scrollSpreadForce: 50, // Сила разлёта при скролле
            scrollDepth: 300 // Глубина скролла (vh) - скрыт в UI
        };

        // ========== НАСТРОЙКА SVG ==========
        // Путь к SVG файлу
        const SVG_PATH = 'Starting Point.svg';

        // ========== СОЗДАНИЕ КРУГЛОЙ ТЕКСТУРЫ ==========
        function createCircleTexture(size = 64) {
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:227',message:'createCircleTexture entry',data:{size:size},timestamp:Date.now(),sessionId:'debug-session',runId:'initial',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const center = size / 2;
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:234',message:'before drawing circle',data:{center:center,radius:center,canvasSize:size},timestamp:Date.now(),sessionId:'debug-session',runId:'initial',hypothesisId:'B'})}).catch(()=>{});
            // #endregion
            
            // Очищаем canvas прозрачным цветом (гипотеза A, E)
            ctx.clearRect(0, 0, size, size);
            
            // Сплошной белый круг без градиента
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath();
            ctx.arc(center, center, center, 0, Math.PI * 2);
            ctx.fill();
            
            // #region agent log
            // Проверяем пиксели в углу canvas (должны быть прозрачными)
            const cornerImageData = ctx.getImageData(0, 0, 1, 1);
            const centerImageData = ctx.getImageData(center, center, 1, 1);
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:245',message:'after drawing circle',data:{cornerPixel:[cornerImageData.data[0],cornerImageData.data[1],cornerImageData.data[2],cornerImageData.data[3]],centerPixel:[centerImageData.data[0],centerImageData.data[1],centerImageData.data[2],centerImageData.data[3]]},timestamp:Date.now(),sessionId:'debug-session',runId:'initial',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            
            const texture = new THREE.CanvasTexture(canvas);
            // Устанавливаем premultipliedAlpha в false для правильного смешивания прозрачности
            // Это предотвращает чёрную обводку при наложении точек
            texture.premultipliedAlpha = false;
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:257',message:'texture created with premultipliedAlpha false',data:{premultipliedAlpha:texture.premultipliedAlpha,format:texture.format,type:texture.type},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'C'})}).catch(()=>{});
            // #endregion
            return texture;
        }

        // ========== ИНИЦИАЛИЗАЦИЯ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Ортографическая камера для устранения перспективных искажений
        const viewSize = 20; // Размер видимой области
        const aspect = window.innerWidth / window.innerHeight;
        const left = -viewSize * aspect / 2;
        const right = viewSize * aspect / 2;
        const top = viewSize / 2;
        const bottom = -viewSize / 2;
        
        const camera = new THREE.OrthographicCamera(
            left,
            right,
            top,
            bottom,
            0.1,
            1000
        );
        camera.position.z = 12;
        camera.position.y = 0;
        camera.position.x = 0;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Настраиваем рендерер для правильного смешивания прозрачности
        renderer.setClearColor(0x000000, 1);
        // #region agent log
        fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:297',message:'renderer configured',data:{antialias:true,alpha:true},timestamp:Date.now(),sessionId:'debug-session',runId:'blending-fix',hypothesisId:'F'})}).catch(()=>{});
        // #endregion
        document.body.appendChild(renderer.domElement);
        
        // ========== ЧАСТИЦЫ ==========
        let geometry = null;
        let positions = new Float32Array(CONFIG.particleCount * 3);
        let originalPositions = new Float32Array(CONFIG.particleCount * 3);
        let baseOriginalPositions = new Float32Array(CONFIG.particleCount * 3); // Базовые исходные позиции без скролла
        let scrollDirections = new Float32Array(CONFIG.particleCount * 3); // Случайные направления разлёта для каждой частицы
        let velocities = new Float32Array(CONFIG.particleCount * 3);
        let colors = new Float32Array(CONFIG.particleCount * 3); // Цвета для каждой точки (RGB)
        let points = null;
        let svgGeometry = null;
        let cloudCenter = new THREE.Vector3(0, 0, 0); // Центр облака частиц
        
        const circleTexture = createCircleTexture(64);
        // #region agent log
        fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:307',message:'creating PointsMaterial with blending',data:{texturePremultipliedAlpha:circleTexture.premultipliedAlpha,blendingMode:'AdditiveBlending'},timestamp:Date.now(),sessionId:'debug-session',runId:'blending-fix',hypothesisId:'F'})}).catch(()=>{});
        // #endregion
        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: CONFIG.pointSize,
            transparent: true,
            opacity: 1.0, // Полная непрозрачность для сплошных точек
            map: circleTexture,
            alphaTest: 0.0, // Убираем alphaTest для предотвращения отсечения краёв
            sizeAttenuation: true,
            vertexColors: true, // Включаем использование цветов вершин
            depthWrite: false, // Отключаем depthWrite для правильного смешивания при наложении
            blending: THREE.AdditiveBlending // Аддитивное смешивание для эффекта слияния точек
        });
        // #region agent log
        fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:322',message:'PointsMaterial created with blending',data:{materialTransparent:material.transparent,materialAlphaTest:material.alphaTest,materialDepthWrite:material.depthWrite,materialBlending:material.blending,blendingConstant:THREE.AdditiveBlending},timestamp:Date.now(),sessionId:'debug-session',runId:'blending-fix',hypothesisId:'F'})}).catch(()=>{});
        // #endregion
        
        console.log('Three.js загружен:', typeof THREE !== 'undefined');
        console.log('SVGLoader загружен:', typeof SVGLoader !== 'undefined');
        
        // Функция для проверки, находится ли точка внутри mesh (оптимизированная версия)
        // Использует меньше направлений для ускорения, но сохраняет точность
        function isPointInsideMesh(point, mesh, raycaster) {
            try {
                // #region agent log
                if (typeof window !== 'undefined' && !window._isPointInsideMeshCallCount) {
                    window._isPointInsideMeshCallCount = 0;
                }
                if (typeof window !== 'undefined') {
                    window._isPointInsideMeshCallCount++;
                    if (window._isPointInsideMeshCallCount % 100 === 0) {
                        fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:278',message:'isPointInsideMesh call count',data:{callCount:window._isPointInsideMeshCallCount},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                    }
                }
                // #endregion
                // Используем только 3 направления для ускорения (вместо 6)
                // Это достаточно для определения, находится ли точка внутри объёма
                const directions = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(0, 0, 1)
                ];
                
                let insideCount = 0;
                let totalChecks = 0;
                
                // Проверяем по каждому направлению
                for (const direction of directions) {
                    raycaster.set(point, direction);
                    const intersects = raycaster.intersectObject(mesh, false);
                    // Если нечётное число пересечений, точка внутри по этому направлению
                    const isInside = intersects.length % 2 === 1;
                    if (isInside) {
                        insideCount++;
                    }
                    totalChecks++;
                }
                
                // Точка считается внутри, если она внутри по большинству направлений (минимум 2 из 3)
                const threshold = Math.ceil(totalChecks * 0.6); // Минимум 2 из 3
                return insideCount >= threshold;
            } catch (error) {
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:310',message:'isPointInsideMesh error',data:{error:error.message},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                console.error('Ошибка в isPointInsideMesh:', error);
                return false;
            }
        }

        // Функция для получения точек для закрашивания SVG формы (2D плоскость)
        // Генерирует точки на поверхности SVG для их закрашивания
        function getShapeVolumePoints(shapeGeometry, count, raycaster) {
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:326',message:'getShapeVolumePoints entry',data:{count:count},timestamp:Date.now(),sessionId:'debug-session',runId:'hybrid-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            const points = [];
            const positions = shapeGeometry.attributes.position;
            const indices = shapeGeometry.index;
            
            // Получаем все вершины из геометрии текста
            const vertices = [];
            for (let i = 0; i < positions.count; i++) {
                const v = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                vertices.push(v);
            }
            
            // Вычисляем площади треугольников для равномерного распределения
            const triangles = [];
            let totalArea = 0;
            
            if (indices && indices.count > 0) {
                // Используем существующие индексы
                for (let i = 0; i < indices.count; i += 3) {
                    const i1 = indices.getX(i);
                    const i2 = indices.getX(i + 1);
                    const i3 = indices.getX(i + 2);
                    
                    const v1 = vertices[i1];
                    const v2 = vertices[i2];
                    const v3 = vertices[i3];
                    
                    // Вычисляем площадь треугольника
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const area = edge1.cross(edge2).length() * 0.5;
                    
                    // Игнорируем вырожденные треугольники (слишком маленькие)
                    if (area > 0.0001) {
                        triangles.push({ v1, v2, v3, area });
                        totalArea += area;
                    }
                }
            } else {
                // Если нет индексов, создаем треугольники из позиций напрямую
                for (let i = 0; i < vertices.length - 2; i += 3) {
                    const v1 = vertices[i];
                    const v2 = vertices[i + 1];
                    const v3 = vertices[i + 2];
                    
                    // Вычисляем площадь треугольника
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const area = edge1.cross(edge2).length() * 0.5;
                    
                    if (area > 0.0001) {
                        triangles.push({ v1, v2, v3, area });
                        totalArea += area;
                    }
                }
            }
            
            if (triangles.length === 0) {
                // Fallback: используем вершины
                if (vertices.length <= count) {
                    return vertices.map(v => v.clone());
                }
                const step = vertices.length / count;
                for (let i = 0; i < count; i++) {
                    const index = Math.floor(i * step);
                    points.push(vertices[index].clone());
                }
                return points;
            }
            
            // Вычисляем накопленные площади для взвешенного выбора треугольников
            const cumulativeAreas = [];
            let cumulativeSum = 0;
            for (const tri of triangles) {
                cumulativeSum += tri.area;
                cumulativeAreas.push(cumulativeSum);
            }
            
            // Фильтруем треугольники: используем только те, что обращены "вверх" (нормаль с положительным Z)
            // Это исключает внутренние грани отверстий
            const frontFacingTriangles = [];
            let frontFacingArea = 0;
            
            for (const tri of triangles) {
                // Вычисляем нормаль треугольника
                const edge1 = new THREE.Vector3().subVectors(tri.v2, tri.v1);
                const edge2 = new THREE.Vector3().subVectors(tri.v3, tri.v1);
                const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                
                // Используем только треугольники с нормалью, направленной вверх (Z > 0)
                // Это исключает внутренние грани отверстий
                if (normal.z > 0 && normal.length() > 0.0001) {
                    frontFacingTriangles.push({ ...tri, area: tri.area });
                    frontFacingArea += tri.area;
                }
            }
            
            // Если нет треугольников, обращённых вверх, используем все
            const trianglesToUse = frontFacingTriangles.length > 0 ? frontFacingTriangles : triangles;
            const areaToUse = frontFacingTriangles.length > 0 ? frontFacingArea : totalArea;
            
            // Вычисляем накопленные площади для выбранных треугольников
            const filteredCumulativeAreas = [];
            let filteredCumulativeSum = 0;
            for (const tri of trianglesToUse) {
                filteredCumulativeSum += tri.area;
                filteredCumulativeAreas.push(filteredCumulativeSum);
            }
            
            // Генерируем точки на поверхности букв (2D плоскость)
            const surfacePoints = [];
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:395',message:'generating 2D surface points',data:{triangleCount:triangles.length,frontFacingCount:trianglesToUse.length,needed:count},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // Генерируем точки на поверхности треугольников
            for (let i = 0; i < count; i++) {
                // Выбираем треугольник взвешенно по площади
                const randomArea = Math.random() * areaToUse;
                let triangleIndex = 0;
                for (let j = 0; j < filteredCumulativeAreas.length; j++) {
                    if (randomArea <= filteredCumulativeAreas[j]) {
                        triangleIndex = j;
                        break;
                    }
                }
                
                const triangle = trianglesToUse[triangleIndex];
                
                // Генерируем случайную точку на поверхности треугольника
                let u = Math.random();
                let v = Math.random();
                if (u + v > 1) {
                    u = 1 - u;
                    v = 1 - v;
                }
                const w = 1 - u - v;
                
                const surfacePoint = new THREE.Vector3();
                surfacePoint.addScaledVector(triangle.v1, u);
                surfacePoint.addScaledVector(triangle.v2, v);
                surfacePoint.addScaledVector(triangle.v3, w);
                
                // Устанавливаем Z в 0 для плоского текста (проецируем на плоскость Z=0)
                surfacePoint.z = 0;
                
                surfacePoints.push(surfacePoint);
            }
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:425',message:'point generation completed',data:{generated:surfacePoints.length,needed:count},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:420',message:'2D surface points generated',data:{generated:surfacePoints.length,needed:count,triangles:triangles.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            
            // Если точек недостаточно, дублируем существующие
            if (surfacePoints.length === 0) {
                console.error('Не удалось сгенерировать точки! triangles:', triangles.length, 'vertices:', vertices.length);
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:450',message:'ERROR: no points generated',data:{triangles:triangles.length,vertices:vertices.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
                // #endregion
            } else if (surfacePoints.length < count) {
                // Если точек меньше нужного, дублируем существующие
                const needed = count - surfacePoints.length;
                for (let i = 0; i < needed; i++) {
                    const index = i % surfacePoints.length;
                    surfacePoints.push(surfacePoints[index].clone());
                }
                // #region agent log
                fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:455',message:'duplicated points to reach count',data:{original:surfacePoints.length-needed,duplicated:needed,final:surfacePoints.length},timestamp:Date.now(),sessionId:'debug-session',runId:'2d-approach',hypothesisId:'G'})}).catch(()=>{});
                // #endregion
            }
            
            // Возвращаем сгенерированные точки
            return surfacePoints.map(p => p.clone());
            
            // #region agent log
            fetch('http://127.0.0.1:7245/ingest/89b2e029-a23d-413f-83ed-b51c0fc8924c',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:453',message:'getShapeVolumePoints exit',data:{returnedCount:points.length},timestamp:Date.now(),sessionId:'debug-session',runId:'hybrid-approach',hypothesisId:'G'})}).catch(()=>{});
            // #endregion
            return points;
        }
        
        // Кэш для загруженного SVG
        let cachedSVGData = null;
        let svgLoadPromise = null;
        
        // Функция загрузки SVG (с кэшированием)
        function loadSVG() {
            // Если SVG уже загружен, возвращаем его сразу
            if (cachedSVGData) {
                return Promise.resolve(cachedSVGData);
            }
            
            // Если SVG уже загружается, возвращаем существующий промис
            if (svgLoadPromise) {
                return svgLoadPromise;
            }
            
            // Создаем новый промис для загрузки SVG
            svgLoadPromise = new Promise((resolve, reject) => {
                const loader = new SVGLoader();
                
                loader.load(
                    SVG_PATH,
                    (data) => {
                        cachedSVGData = data; // Кэшируем загруженный SVG
                        svgLoadPromise = null; // Сбрасываем промис после успешной загрузки
                        resolve(data);
                    },
                    undefined,
                    (error) => {
                        svgLoadPromise = null; // Сбрасываем промис при ошибке
                        reject(new Error(`Не удалось загрузить SVG: ${error}`));
                    }
                );
            });
            
            return svgLoadPromise;
        }
        
        // Функция создания геометрии из SVG
        async function createSVGGeometry(size = 2) {
            // Загружаем SVG (используем кэш, если он уже загружен)
            const svgData = await loadSVG();
            
            // Получаем paths из SVG
            if (!svgData.paths || svgData.paths.length === 0) {
                throw new Error('SVG не содержит path элементов');
            }
            
            // Собираем все shapes из всех paths
            const allShapes = [];
            
            for (const path of svgData.paths) {
                const shapesFromPath = SVGLoader.createShapes(path);
                allShapes.push(...shapesFromPath);
            }
            
            if (allShapes.length === 0) {
                throw new Error('Не удалось создать shapes из SVG paths');
            }
            
            // Создаем геометрию из всех shapes
            const geometries = [];
            
            for (const shape of allShapes) {
                const geometry = new THREE.ShapeGeometry(shape);
                geometries.push(geometry);
            }
            
            // Объединяем все геометрии в одну
            let mergedGeometry;
            if (geometries.length === 1) {
                mergedGeometry = geometries[0];
            } else {
                // Используем BufferGeometryUtils.mergeGeometries() вместо несуществующего метода merge()
                mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
            }
            
            // Вычисляем bounding box для масштабирования
            mergedGeometry.computeBoundingBox();
            const bbox = mergedGeometry.boundingBox;
            const svgWidth = bbox.max.x - bbox.min.x;
            const svgHeight = bbox.max.y - bbox.min.y;
            const svgMaxDimension = Math.max(svgWidth, svgHeight);
            
            // Масштабируем геометрию
            const scale = size / svgMaxDimension;
            mergedGeometry.scale(scale, -scale, 1); // Отрицательный Y для инверсии (SVG origin top-left, Three.js bottom-left)
            
            // Центрируем геометрию
            mergedGeometry.computeBoundingBox();
            mergedGeometry.center();
            mergedGeometry.computeBoundingBox();
            
            return mergedGeometry;
        }
        
        // Кэш для базового размера SVG (чтобы не вычислять каждый раз)
        let cachedSVGBaseSize = null;
        
        // Функция вычисления оптимального размера SVG
        async function calculateOptimalSVGSize(baseSize = 1.0) {
            if (cachedSVGBaseSize === null) {
                // Создаем временную геометрию для вычисления bounding box
                const tempGeometry = await createSVGGeometry(baseSize);
                tempGeometry.computeBoundingBox();
                
                // Вычисляем размер SVG
                const bbox = tempGeometry.boundingBox;
                const svgWidth = bbox.max.x - bbox.min.x;
                const svgHeight = bbox.max.y - bbox.min.y;
                cachedSVGBaseSize = Math.max(svgWidth, svgHeight);
                
                // Освобождаем память
                tempGeometry.dispose();
            }
            
            // Для ортографической камеры видимая ширина не зависит от расстояния
            // Вычисляем видимую ширину из параметров камеры
            const visibleWidth = camera.right - camera.left;
            
            // Масштабируем SVG так, чтобы он занимал максимум 80% видимой ширины
            // Возвращаем базовый scaleFactor (для sphereRadius=1.0)
            const targetWidth = visibleWidth * 0.8;
            const baseScaleFactor = targetWidth / cachedSVGBaseSize;
            
            return baseScaleFactor;
        }
        
        // Функция генерации частиц на основе SVG
        async function generateParticlesFromSVG() {
            // Всегда пересоздаем геометрию, если она не существует
            // Вычисляем базовый масштаб для SVG (для sphereRadius=1.0, SVG занимает 80% ширины)
            const baseScaleFactor = await calculateOptimalSVGSize();
            
                // Применяем CONFIG.sphereRadius как множитель, но ограничиваем максимальный размер
                // чтобы SVG всегда помещался во вьюпорт (максимум 95% видимой ширины)
                // Для ортографической камеры видимая ширина не зависит от расстояния
                const visibleWidth = camera.right - camera.left;
                const maxSVGWidth = visibleWidth * 0.95; // Максимум 95% ширины
            
            // Вычисляем максимально допустимый scaleFactor
            const maxScaleFactor = maxSVGWidth / cachedSVGBaseSize;
            
            // Применяем sphereRadius, но ограничиваем максимальным размером
            const scaleFactor = Math.min(baseScaleFactor * CONFIG.sphereRadius, maxScaleFactor);
            const finalSize = scaleFactor;
            
            // Создаем финальную геометрию с правильным размером
            svgGeometry = await createSVGGeometry(finalSize);
            svgGeometry.computeBoundingBox();
            
            // Используем raycaster для проверки точек внутри объёма
            const tempRaycaster = new THREE.Raycaster();
            const volumePoints = getShapeVolumePoints(svgGeometry, CONFIG.particleCount, tempRaycaster);
            
            positions = new Float32Array(CONFIG.particleCount * 3);
            originalPositions = new Float32Array(CONFIG.particleCount * 3);
            velocities = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);
            
            let particlesCreated = 0;
            let posMinX=Infinity,posMaxX=-Infinity,posMinY=Infinity,posMaxY=-Infinity,posMinZ=Infinity,posMaxZ=-Infinity;
            for (let i = 0; i < CONFIG.particleCount && i < volumePoints.length; i++) {
                const i3 = i * 3;
                const point = volumePoints[i];
                
                positions[i3] = point.x;
                positions[i3 + 1] = point.y;
                positions[i3 + 2] = point.z;
                
                posMinX=Math.min(posMinX,point.x);posMaxX=Math.max(posMaxX,point.x);
                posMinY=Math.min(posMinY,point.y);posMaxY=Math.max(posMaxY,point.y);
                posMinZ=Math.min(posMinZ,point.z);posMaxZ=Math.max(posMaxZ,point.z);
                
                originalPositions[i3] = point.x;
                originalPositions[i3 + 1] = point.y;
                originalPositions[i3 + 2] = point.z;
                
                // Сохраняем базовые исходные позиции
                baseOriginalPositions[i3] = point.x;
                baseOriginalPositions[i3 + 1] = point.y;
                baseOriginalPositions[i3 + 2] = point.z;
                
                // Генерируем случайное направление разлёта для каждой частицы (один раз при инициализации)
                const theta = Math.random() * Math.PI * 2; // Азимутальный угол (0 до 2π)
                const phi = Math.acos(2 * Math.random() - 1); // Полярный угол (равномерное распределение на сфере)
                scrollDirections[i3] = Math.sin(phi) * Math.cos(theta);
                scrollDirections[i3 + 1] = Math.sin(phi) * Math.sin(theta);
                scrollDirections[i3 + 2] = Math.cos(phi);
                
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                
                // Инициализируем цвета как белые (1, 1, 1)
                colors[i3] = 1.0;
                colors[i3 + 1] = 1.0;
                colors[i3 + 2] = 1.0;
                particlesCreated++;
            }
            
            // Вычисляем центр облака частиц
            cloudCenter.set(0, 0, 0);
            for (let i = 0; i < particlesCreated; i++) {
                const i3 = i * 3;
                cloudCenter.x += baseOriginalPositions[i3];
                cloudCenter.y += baseOriginalPositions[i3 + 1];
                cloudCenter.z += baseOriginalPositions[i3 + 2];
            }
            if (particlesCreated > 0) {
                cloudCenter.divideScalar(particlesCreated);
            }
        }
        
        // Функция пересоздания системы точек
        async function recreateParticles() {
            await generateParticlesFromSVG();
            
            if (points) {
                scene.remove(points);
                geometry.dispose();
            }
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            points = new THREE.Points(geometry, material);
            scene.add(points);
            // Обновляем исходные позиции на основе текущего скролла
            updateOriginalPositionsFromScroll();
        }
        
        // Функция масштабирования SVG объекта
        async function scaleSVGObject(newSize) {
            CONFIG.sphereRadius = newSize;
            
            // Пересоздаем SVG геометрию с новым размером
            svgGeometry = null;
            cachedSVGBaseSize = null; // Сбрасываем кэш размера
            await generateParticlesFromSVG();
            
            // Обновляем геометрию точек
            if (points) {
                scene.remove(points);
                if (geometry) {
                    geometry.dispose();
                }
            }
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            points = new THREE.Points(geometry, material);
            scene.add(points);
        }
        
        // Флаг готовности
        let isInitialized = false;
        
        // Инициализация
        (async () => {
            try {
                await generateParticlesFromSVG();
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                points = new THREE.Points(geometry, material);
                scene.add(points);
                isInitialized = true;
                // Обновляем исходные позиции на основе текущего скролла
                updateOriginalPositionsFromScroll();
                console.log('Инициализация завершена успешно');
            } catch (error) {
                console.error('Ошибка при инициализации SVG:', error);
                document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: monospace; background: #222; position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; z-index: 10000; flex-direction: column; text-align: center;"><h2>Ошибка загрузки SVG</h2><p>Не удалось загрузить SVG файл "Starting Point.svg".</p><p style="color: #999; font-size: 12px; margin-top: 20px;">Проверьте консоль браузера (F12) для деталей.</p></div>';
            }
        })();
        
        // ========== ВЗАИМОДЕЙСТВИЕ ==========
        const mouse = new THREE.Vector2();
        const mouse3D = new THREE.Vector3();
        const previousMouse = new THREE.Vector2();
        const mouseVelocity = new THREE.Vector2();
        
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        
        function updateMousePosition(event) {
            previousMouse.copy(mouse);
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            mouseVelocity.x = mouse.x - previousMouse.x;
            mouseVelocity.y = mouse.y - previousMouse.y;
            
            raycaster.setFromCamera(mouse, camera);
            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectionPoint);
            mouse3D.copy(intersectionPoint);
        }
        
        let isPointerDown = false;
        
        function onPointerMove(event) {
            updateMousePosition(event);
        }
        
        function onPointerDown(event) {
            isPointerDown = true;
            updateMousePosition(event);
        }
        
        function onPointerUp(event) {
            isPointerDown = false;
        }
        
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        
        // ========== СКРОЛЛ ==========
        let scrollProgress = 0; // Нормализованная позиция скролла (0-1)
        let previousScrollProgress = 0;
        
        // Функция обновления исходных позиций на основе скролла
        function updateOriginalPositionsFromScroll() {
            if (!isInitialized || baseOriginalPositions.length === 0) return;
            
            const actualParticleCount = Math.min(CONFIG.particleCount, baseOriginalPositions.length / 3);
            const spreadDistance = scrollProgress * CONFIG.scrollSpreadForce * 0.1; // Расстояние разлёта
            
            for (let i = 0; i < actualParticleCount; i++) {
                const i3 = i * 3;
                // Вычисляем смещённую исходную позицию на основе базовой позиции и направления разлёта
                originalPositions[i3] = baseOriginalPositions[i3] + scrollDirections[i3] * spreadDistance;
                originalPositions[i3 + 1] = baseOriginalPositions[i3 + 1] + scrollDirections[i3 + 1] * spreadDistance;
                originalPositions[i3 + 2] = baseOriginalPositions[i3 + 2] + scrollDirections[i3 + 2] * spreadDistance;
            }
        }
        
        function updateScrollProgress() {
            const maxScroll = (CONFIG.scrollDepth * window.innerHeight) / 100;
            previousScrollProgress = scrollProgress;
            scrollProgress = Math.max(0, Math.min(1, window.scrollY / maxScroll));
            
            // Обновляем исходные позиции только если scrollProgress изменился
            if (Math.abs(scrollProgress - previousScrollProgress) > 0.001) {
                updateOriginalPositionsFromScroll();
            }
        }
        
        // Throttling для производительности
        let scrollTimeout = null;
        window.addEventListener('scroll', () => {
            if (scrollTimeout === null) {
                scrollTimeout = requestAnimationFrame(() => {
                    updateScrollProgress();
                    scrollTimeout = null;
                });
            }
        }, { passive: true });
        
        // Инициализация при загрузке
        updateScrollProgress();
        
        // ========== ФИЗИКА ==========
        const tempVector = new THREE.Vector3();
        const tempVector2 = new THREE.Vector3();
        const tempVector3 = new THREE.Vector3();
        const tempVector4 = new THREE.Vector3(); // Дополнительный временный вектор для вычислений
        const tempVector5 = new THREE.Vector3(); // Временный вектор для скролла
        
        // Функция для генерации случайного 3D направления с угловым отклонением
        function randomDirection3D(baseDirection, maxAngleDegrees, chaosStrength) {
            // Преобразуем угол в радианы
            const maxAngle = (maxAngleDegrees * Math.PI) / 180;
            
            // Генерируем случайный угол отклонения (0 до maxAngle)
            const angle = Math.random() * maxAngle * chaosStrength;
            
            // Генерируем случайный азимутальный угол (0 до 2π)
            const azimuth = Math.random() * Math.PI * 2;
            
            // Генерируем случайный вектор перпендикулярный базовому направлению
            // Используем метод генерации случайного вектора в сфере
            let perpendicular = new THREE.Vector3();
            if (Math.abs(baseDirection.x) < 0.9) {
                perpendicular.set(1, 0, 0);
            } else {
                perpendicular.set(0, 1, 0);
            }
            perpendicular.crossVectors(baseDirection, perpendicular).normalize();
            
            // Создаём второй перпендикулярный вектор
            const perpendicular2 = new THREE.Vector3().crossVectors(baseDirection, perpendicular).normalize();
            
            // Генерируем случайное отклонение в плоскости, перпендикулярной базовому направлению
            const cosAngle = Math.cos(angle);
            const sinAngle = Math.sin(angle);
            const cosAzimuth = Math.cos(azimuth);
            const sinAzimuth = Math.sin(azimuth);
            
            // Комбинируем базовое направление с перпендикулярными компонентами
            const result = new THREE.Vector3()
                .copy(baseDirection)
                .multiplyScalar(cosAngle)
                .addScaledVector(perpendicular, sinAngle * cosAzimuth)
                .addScaledVector(perpendicular2, sinAngle * sinAzimuth)
                .normalize();
            
            return result;
        }
        
        function updatePhysics() {
            // Проверяем, что геометрия инициализирована
            if (!isInitialized || !geometry || !geometry.attributes.position) {
                return;
            }
            
            const positionsArray = geometry.attributes.position.array;
            const colorsArray = geometry.attributes.color ? geometry.attributes.color.array : null;
            
            // Проверяем, что массив имеет правильный размер
            const actualParticleCount = Math.min(CONFIG.particleCount, positionsArray.length / 3);
            
            // Определяем диапазон расстояний для нормализации
            let minDistance = Infinity;
            let maxDistance = -Infinity;
            const distances = [];
            
            // Сначала вычисляем все расстояния
            for (let i = 0; i < actualParticleCount; i++) {
                const i3 = i * 3;
                if (i3 + 2 >= positionsArray.length) break;
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                const distance = tempVector.distanceTo(camera.position);
                distances.push(distance);
                minDistance = Math.min(minDistance, distance);
                maxDistance = Math.max(maxDistance, distance);
            }
            
            // Нормализуем диапазон, чтобы избежать слишком резких переходов
            const distanceRange = Math.max(maxDistance - minDistance, 0.1);
            
            const speed = Math.sqrt(mouseVelocity.x * mouseVelocity.x + mouseVelocity.y * mouseVelocity.y);
            const forceMultiplier = Math.min(speed * CONFIG.forceStrength, CONFIG.forceStrength * 2);
            
            for (let i = 0; i < actualParticleCount; i++) {
                const i3 = i * 3;
                if (i3 + 2 >= positionsArray.length) break;
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                
                const distance = tempVector.distanceTo(mouse3D);
                
                if (distance < CONFIG.interactionRadius && (isPointerDown || speed > 0.001)) {
                    // Базовое направление от курсора к точке
                    const baseDirection = tempVector2.subVectors(tempVector, mouse3D).normalize();
                    
                    // Применяем случайное угловое отклонение для создания хаотичности
                    const chaoticDirection = randomDirection3D(
                        baseDirection, 
                        CONFIG.chaosAngle, 
                        CONFIG.chaosStrength
                    );
                    
                    // Вычисляем тангенциальное направление (перпендикулярно радиус-вектору)
                    // Используем векторное произведение для получения перпендикулярного вектора
                    let tangent = tempVector4.crossVectors(baseDirection, new THREE.Vector3(0, 0, 1));
                    if (tangent.length() < 0.1) {
                        // Если векторы коллинеарны, используем другой базовый вектор
                        tangent.crossVectors(baseDirection, new THREE.Vector3(1, 0, 0));
                    }
                    tangent.normalize();
                    
                    // Создаём второй перпендикулярный вектор для полного тангенциального пространства
                    const tangent2 = new THREE.Vector3().crossVectors(baseDirection, tangent).normalize();
                    
                    // Добавляем случайную тангенциальную компоненту в плоскости, перпендикулярной радиус-вектору
                    const tangentialAngle = Math.random() * Math.PI * 2;
                    const tangentX = Math.cos(tangentialAngle);
                    const tangentY = Math.sin(tangentialAngle);
                    tangent.multiplyScalar(tangentX).addScaledVector(tangent2, tangentY);
                    
                    // Вычисляем силу с расстоянием
                    const distanceFactor = 1 - distance / CONFIG.interactionRadius;
                    const baseForce = distanceFactor * forceMultiplier;
                    
                    // Добавляем случайную вариацию силы (0.7-1.3)
                    const forceVariation = 0.7 + Math.random() * 0.6;
                    const force = baseForce * forceVariation;
                    
                    // Комбинируем радиальную и тангенциальную силы
                    const radialForce = force * (1 - CONFIG.tangentialForceRatio);
                    const tangentialForce = force * CONFIG.tangentialForceRatio;
                    
                    // Добавляем случайную Z-компоненту для трёхмерности
                    const zComponent = (Math.random() - 0.5) * 2 * CONFIG.zAxisStrength;
                    
                    // Применяем силы к скорости
                    const finalDirection = new THREE.Vector3()
                        .copy(chaoticDirection)
                        .multiplyScalar(radialForce)
                        .addScaledVector(tangent, tangentialForce);
                    
                    velocities[i3] += finalDirection.x * 0.2 * CONFIG.timeScale;
                    velocities[i3 + 1] += finalDirection.y * 0.2 * CONFIG.timeScale;
                    velocities[i3 + 2] += (finalDirection.z + zComponent) * 0.2 * CONFIG.timeScale;
                }
                
                // Автономное движение - плавные случайные силы (применяются не каждый кадр для плавности)
                if (CONFIG.autonomousMotionStrength > 0 && Math.random() < 0.3) {
                    velocities[i3] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3 * CONFIG.timeScale;
                    velocities[i3 + 1] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3 * CONFIG.timeScale;
                    velocities[i3 + 2] += (Math.random() - 0.5) * CONFIG.autonomousMotionStrength * 0.3 * CONFIG.timeScale;
                }
                
                positionsArray[i3] += velocities[i3] * CONFIG.timeScale;
                positionsArray[i3 + 1] += velocities[i3 + 1] * CONFIG.timeScale;
                positionsArray[i3 + 2] += velocities[i3 + 2] * CONFIG.timeScale;
                
                tempVector.set(
                    positionsArray[i3],
                    positionsArray[i3 + 1],
                    positionsArray[i3 + 2]
                );
                
                // Система пружины-демпфера для возврата к исходной позиции
                tempVector3.set(
                    originalPositions[i3],
                    originalPositions[i3 + 1],
                    originalPositions[i3 + 2]
                );
                
                // Вычисляем смещение от исходной позиции
                const displacement = tempVector2.subVectors(tempVector3, tempVector);
                const displacementLength = displacement.length();
                const velocityLength = Math.sqrt(
                    velocities[i3] * velocities[i3] + 
                    velocities[i3 + 1] * velocities[i3 + 1] + 
                    velocities[i3 + 2] * velocities[i3 + 2]
                );
                
                // Если смещение и скорость очень маленькие, просто возвращаем на место и останавливаем
                const threshold = 0.001; // Порог для остановки
                if (displacementLength < threshold && velocityLength < threshold) {
                    positionsArray[i3] = originalPositions[i3];
                    positionsArray[i3 + 1] = originalPositions[i3 + 1];
                    positionsArray[i3 + 2] = originalPositions[i3 + 2];
                    velocities[i3] = 0;
                    velocities[i3 + 1] = 0;
                    velocities[i3 + 2] = 0;
                } else {
                    // Применяем силу пружины: F_spring = springConstant * displacement
                    const springForceX = displacement.x * CONFIG.springConstant;
                    const springForceY = displacement.y * CONFIG.springConstant;
                    const springForceZ = displacement.z * CONFIG.springConstant;
                    
                    // Обновляем скорость: velocity += F_spring * dt
                    // dt примерно равен 1/60 (60 FPS), но для стабильности используем фиксированный шаг
                    const dt = 0.016 * CONFIG.timeScale; // Применяем глобальный множитель скорости
                    velocities[i3] += springForceX * dt;
                    velocities[i3 + 1] += springForceY * dt;
                    velocities[i3 + 2] += springForceZ * dt;
                    
                    // Применяем демпфирование: экспоненциальное затухание скорости
                    // damping близко к 1.0 означает сильное затухание
                    velocities[i3] *= CONFIG.damping;
                    velocities[i3 + 1] *= CONFIG.damping;
                    velocities[i3 + 2] *= CONFIG.damping;
                    
                    // Обновляем позицию: position += velocity * dt
                    positionsArray[i3] += velocities[i3] * dt;
                    positionsArray[i3 + 1] += velocities[i3 + 1] * dt;
                    positionsArray[i3 + 2] += velocities[i3 + 2] * dt;
                }
                
                // Обновляем цвет на основе расстояния от камеры
                if (colorsArray && i < distances.length && i3 + 2 < colorsArray.length) {
                    const distance = distances[i];
                    // Нормализуем расстояние от 0 до 1
                    const normalizedDistance = distanceRange > 0 ? (distance - minDistance) / distanceRange : 0;
                    // Инвертируем: ближние точки ярче (1.0), дальние темнее (0.0)
                    const brightness = 1.0 - normalizedDistance; // От 1.0 до 0.0
                    const clampedBrightness = Math.max(0.0, Math.min(1.0, brightness));
                    
                    colorsArray[i3] = clampedBrightness;
                    colorsArray[i3 + 1] = clampedBrightness;
                    colorsArray[i3 + 2] = clampedBrightness;
                }
            }
            
            geometry.attributes.position.needsUpdate = true;
            if (geometry.attributes.color) {
                geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // ========== ПАНЕЛЬ НАСТРОЕК ==========
        const controls = document.getElementById('controls');
        const toggleBtn = document.getElementById('toggleControls');
        
        toggleBtn.addEventListener('click', () => {
            controls.classList.toggle('hidden');
            toggleBtn.textContent = controls.classList.contains('hidden') ? 'Показать настройки' : 'Скрыть настройки';
        });
        
        // Привязка слайдеров к значениям
        function setupControl(id, configKey, valueId) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                CONFIG[configKey] = value;
                
                // Форматирование значения в зависимости от параметра
                if (id === 'autonomousMotionStrength' || id === 'springConstant' || id === 'damping') {
                    valueDisplay.textContent = value.toFixed(2);
                } else if (value < 1) {
                    valueDisplay.textContent = value.toFixed(2);
                } else {
                    valueDisplay.textContent = value.toFixed(0);
                }
                
                if (id === 'pointSize') {
                    material.size = value;
                }
            });
        }
        
        setupControl('pointSize', 'pointSize', 'pointSizeValue');
        setupControl('forceStrength', 'forceStrength', 'forceStrengthValue');
        setupControl('interactionRadius', 'interactionRadius', 'interactionRadiusValue');
        setupControl('springConstant', 'springConstant', 'springConstantValue');
        setupControl('damping', 'damping', 'dampingValue');
        setupControl('timeScale', 'timeScale', 'timeScaleValue');
        setupControl('autonomousMotionStrength', 'autonomousMotionStrength', 'autonomousMotionStrengthValue');
        setupControl('scrollSpreadForce', 'scrollSpreadForce', 'scrollSpreadForceValue');
        setupControl('scrollDepth', 'scrollDepth', 'scrollDepthValue');
        
        // Обработчик для количества точек с debounce для оптимизации
        const particleCountSlider = document.getElementById('particleCount');
        const particleCountValue = document.getElementById('particleCountValue');
        let particleCountTimeout = null;
        particleCountSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            CONFIG.particleCount = value;
            particleCountValue.textContent = value;
            
            // Debounce: пересоздаём частицы только после остановки изменения слайдера
            clearTimeout(particleCountTimeout);
            particleCountTimeout = setTimeout(async () => {
                await recreateParticles();
            }, 300); // Ждём 300ms после последнего изменения
        });
        
        
        // ========== АНИМАЦИЯ ==========
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            // Обновляем параметры ортографической камеры при изменении размера окна
            const viewSize = 20;
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
